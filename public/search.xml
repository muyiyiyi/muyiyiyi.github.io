<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>opencv笔记（二）颜色空间转换与伪彩色</title>
      <link href="/2019/06/09/%E7%AC%94%E8%AE%B0(%E4%BA%8C)%20-%E9%A2%9C%E8%89%B2%E7%A9%BA%E9%97%B4%E8%BD%AC%E6%8D%A2%E5%92%8C%E4%BC%AA%E5%BD%A9%E8%89%B2/"/>
      <url>/2019/06/09/%E7%AC%94%E8%AE%B0(%E4%BA%8C)%20-%E9%A2%9C%E8%89%B2%E7%A9%BA%E9%97%B4%E8%BD%AC%E6%8D%A2%E5%92%8C%E4%BC%AA%E5%BD%A9%E8%89%B2/</url>
      
        <content type="html"><![CDATA[<p>opencv学习笔记（二） 颜色空间转换与伪彩色<br><a id="more"></a></p><h1 id="颜色空间转换-cvtColor"><a href="#颜色空间转换-cvtColor" class="headerlink" title="颜色空间转换 cvtColor"></a>颜色空间转换 cvtColor</h1><p><a href="https://docs.opencv.org/4.0.0/d8/d01/group__imgproc__color__conversions.html#ga397ae87e1288a81d2363b61574eb8cab" target="_blank" rel="noopener">文档地址</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> cv::cvtColor(InputArray src ,OutputArray dst,<span class="keyword">int</span> code, <span class="keyword">int</span> dstCn=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dst = cv2.cvtColor(src,code[,dst[,dstCn]])</span><br></pre></td></tr></table></figure><p>dstCn :目标图像的通道数，默认值是0，表示由src和code决定</p><p>code表示转换标识，常见的BGR转灰度COLOR_BGR2GRAY</p><p><a href="https://docs.opencv.org/4.0.0/d8/d01/group__imgproc__color__conversions.html#ga4e0972be5de079fed4e3a10e24ef5ef0" target="_blank" rel="noopener">code转换码的取值</a></p><p><em>eg.</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Mat gray;</span><br><span class="line">cvtColor(src, gray, COLOR_BGR2GRAY);</span><br><span class="line">imwrite(<span class="string">"gray.png"</span>, gray);</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gray = cv2.cvtColor(src, cv2.COLOR_BGR2GRAY)</span><br><span class="line">cv2.imwrite(<span class="string">'gray.png'</span>,gray)</span><br></pre></td></tr></table></figure><h1 id="创建新图：克隆复制与赋值"><a href="#创建新图：克隆复制与赋值" class="headerlink" title="创建新图：克隆复制与赋值"></a>创建新图：克隆复制与赋值</h1><p>图像克隆、复制与 赋值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Mat m1 = src.clone(); <span class="comment">//克隆原图像到新图</span></span><br><span class="line"><span class="comment">// 将原图src复制到新的图像m2</span></span><br><span class="line">Mat m2;</span><br><span class="line">src.copyTo(m2);</span><br><span class="line"><span class="comment">// 赋值</span></span><br><span class="line">Mat m3 = src;</span><br><span class="line"><span class="comment">// 创建新图</span></span><br><span class="line">Mat m4 = Mat::zeros(src.size(), src.type());</span><br><span class="line">Mat m5 = Mat::zeros(Size(<span class="number">512</span>, <span class="number">512</span>), CV_8UC3);</span><br><span class="line">Mat m6 = Mat::ones(Size(<span class="number">512</span>, <span class="number">512</span>), CV_8UC3);</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">m1 = np.copy(src)  <span class="comment">#复制原图</span></span><br><span class="line"><span class="comment"># 赋值 切片访问像素</span></span><br><span class="line">m2 = src</span><br><span class="line">src[<span class="number">100</span>:<span class="number">200</span>,<span class="number">200</span>:<span class="number">300</span>,:] = <span class="number">255</span>  <span class="comment"># m2同步更改</span></span><br><span class="line"><span class="comment"># np创建新的矩阵</span></span><br><span class="line">m3 = np.zeros(src.shape, src.dtype)</span><br><span class="line">m4 = np.zeros([<span class="number">512</span>,<span class="number">512</span>], np.uint8)</span><br><span class="line">m5 = np.ones(shape=[<span class="number">512</span>,<span class="number">512</span>,<span class="number">3</span>], dtype=np.uint8)</span><br><span class="line">m5[:,:,<span class="number">0</span>] = <span class="number">255</span></span><br></pre></td></tr></table></figure><h1 id="像素值的访问"><a href="#像素值的访问" class="headerlink" title="像素值的访问"></a>像素值的访问</h1><p>python版本的OpenCV，图像数据就是numpy.array，访问方式和数组一致。</p><p>c++版本的OpenCV，图像数据是Mat类，访问有十几种方式。<a href="https://blog.csdn.net/xiaowei_cqu/article/details/19839019" target="_blank" rel="noopener">https://blog.csdn.net/xiaowei_cqu/article/details/19839019</a></p><p>三种常用的是位置访问、ptr指针和data。此外迭代器等方式也比较高效。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CV_8U   0                   <span class="comment">//对应uchar</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CV_8S   1                   <span class="comment">//对应char</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CV_16U  2                   <span class="comment">//对应ushort</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CV_16S  3                   <span class="comment">//对应short</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CV_32S  4                   <span class="comment">//对应int</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CV_32F  5                   <span class="comment">//对应float</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CV_64F  6                   <span class="comment">//对应double</span></span></span><br><span class="line"><span class="comment">/*   使用模板 成员函数Mat.at&lt;&gt;() */</span></span><br><span class="line"><span class="comment">// 单通道数据</span></span><br><span class="line"><span class="function">Mat <span class="title">img1</span><span class="params">(<span class="number">1</span>,<span class="number">256</span>,CV_8U)</span></span>;<span class="comment">// 1行256列的  二维 单通道数组</span></span><br><span class="line">uchar data = img1.at&lt;uchar&gt;(<span class="number">0</span>,<span class="number">10</span>); <span class="comment">// 访问img1的第一行第11个值 &lt;&gt;中的值由元素的类型决定，上面的定义是对应关系</span></span><br><span class="line"></span><br><span class="line"><span class="function">Mat <span class="title">img2</span><span class="params">(<span class="number">1</span>,<span class="number">256</span>,CV_32FC3)</span></span>;<span class="comment">//1行256的 二维3通道数组</span></span><br><span class="line"><span class="keyword">float</span> data = img2.at&lt;cv::Vec3f&gt;(<span class="number">0</span>,<span class="number">10</span>)[<span class="number">0</span>]; <span class="comment">//img2的第一行第11个位置 第一个通道，三通道的&lt;&gt;参数是vec3f这种，返回的是该位置的三个通道数据，因此需要[]索引访问三个不同的通道的值。 8UC3对应Vec3b</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用ptr指针 */</span></span><br><span class="line"><span class="keyword">int</span> ROWS = <span class="number">100</span>; <span class="comment">// height</span></span><br><span class="line"><span class="keyword">int</span> COLS = <span class="number">200</span>; <span class="comment">// width</span></span><br><span class="line"><span class="function">Mat <span class="title">img1</span><span class="params">(ROWS , COLS , CV_32FC1)</span></span>; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;ROWS ; i++)   </span><br><span class="line">&#123;   </span><br><span class="line">    <span class="keyword">float</span>* pData1=img5.ptr&lt;<span class="keyword">float</span>&gt;(i);  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;COLS ; j++)   </span><br><span class="line">    &#123;   </span><br><span class="line">        pData1[j] = <span class="number">3.2f</span>;   </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Mat.data  */</span></span><br><span class="line"><span class="function">Mat <span class="title">img</span><span class="params">(<span class="number">1</span>,<span class="number">256</span>,CV_8U)</span></span>;</span><br><span class="line">uchar *p = img.data;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">256</span>;i++)&#123;</span><br><span class="line">    p[i] = <span class="number">255</span> -i; <span class="comment">//像素值翻转</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="伪彩色"><a href="#伪彩色" class="headerlink" title="伪彩色"></a>伪彩色</h1><p>将灰度图映射成伪彩色的图像，即将灰度图像的像素灰度值按照线性或者非线性函数映射到彩色空间，从而使呈现出彩色的显示效果。</p><h2 id="applyColorMap"><a href="#applyColorMap" class="headerlink" title="applyColorMap"></a>applyColorMap</h2><p>OpenCV提供的12种彩色图定义如下，函数是applyColorMap。</p><p><img src="/images/4.png" alt="伪彩色映射"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> cv::applyColorMap(InputArray src,OutputArray dst,InputArray userColor)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dst=  cv2.applyColorMap(src, colormap[, dst])</span><br><span class="line">dst=  cv2.applyColorMap(src, userColor[, dst])</span><br></pre></td></tr></table></figure><p>该函数的输入src可以是灰度图，也可以是bgr三通道的图片。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line">src = cv2.imread(<span class="string">'alpha.png'</span>)</span><br><span class="line">gray = cv2.cvtColor(src,cv2.COLOR_BGR2GRAY)</span><br><span class="line">dst=  cv2.applyColorMap(src,cv2.COLORMAP_RAINBOW)</span><br><span class="line"><span class="comment">#ccv2.imshow("src",src)</span></span><br><span class="line">cv2.imshow(<span class="string">"gray"</span>,gray)</span><br><span class="line">cv2.imshow(<span class="string">"color"</span>,dst)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>显示效果如下，伪彩色将灰度图的各个灰度值映射成彩色。</p><p><img src="/images/5.png" alt="1559902994356"></p><h2 id="LUT查找表实现伪彩色"><a href="#LUT查找表实现伪彩色" class="headerlink" title="LUT查找表实现伪彩色"></a>LUT查找表实现伪彩色</h2><p>applycolormap只能使用12中固定的彩色映射，如要实现自定义的伪彩色需要使用cv::LUT，自定义一个查找表，然后将灰度值进行映射。比如定义的colormap，256灰度级的查找表table，将原始灰度值翻转，table[i] = 255 - i 将原始灰度值取反。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> cv :: LUT（InputArray src，InputArray lut，OutputArray DST ）</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DST=cv2.LUT（src，lut [，dst]）</span><br></pre></td></tr></table></figure><p>自定义查找表，实现灰度值翻转的功能。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">src = cv2.imread(<span class="string">'123333.PNG'</span>)</span><br><span class="line">gray = cv2.cvtColor(src,cv2.COLOR_BGR2GRAY)</span><br><span class="line"><span class="comment">#dst=  cv2.applyColorMap(src,cv2.COLORMAP_RAINBOW)</span></span><br><span class="line"><span class="comment">#cv2.imshow("src",src)</span></span><br><span class="line">table = np.zeros((<span class="number">1</span>,<span class="number">256</span>),gray.dtype) <span class="comment">#对单通道灰度图作伪彩色，因此是1,256当然可以定义（3,256）对三通道的分量作不同的映射</span></span><br><span class="line">print(table.shape)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(table[<span class="number">0</span>])):</span><br><span class="line">    table[<span class="number">0</span>][i] = <span class="number">255</span> - i <span class="comment"># 将每个元素的原始灰度值翻转，这个操作若是有溢出就需要判断，255-i不会溢出</span></span><br><span class="line">    <span class="string">'''if table[0][i] &gt;255:</span></span><br><span class="line"><span class="string">        table[0][i]=255</span></span><br><span class="line"><span class="string">    if table[0][i]&lt;0:</span></span><br><span class="line"><span class="string">        table[0][i]=0'''</span></span><br><span class="line">dst =cv2.LUT(gray,table)</span><br><span class="line"><span class="comment">#cv2.imshow("src",src)</span></span><br><span class="line">cv2.imshow(<span class="string">"gray"</span>,gray)</span><br><span class="line">cv2.imshow(<span class="string">"color"</span>,dst)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>显示效果如下图</p><p><img src="/images/6.png" alt="1559905565349"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Mat <span class="title">table</span><span class="params">(<span class="number">1</span>, <span class="number">256</span>, CV_8U)</span></span>;</span><br><span class="line">uchar *p = table.data;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) &#123;</span><br><span class="line">    <span class="comment">//img.at&lt;float&gt;(row,col)</span></span><br><span class="line">    <span class="comment">//table.at&lt;uchar&gt;(0,i) = 255 - i; //等价于p[i]访问像素值 </span></span><br><span class="line">    p[i] = <span class="number">255</span> - i;</span><br><span class="line">&#125;</span><br><span class="line">Mat src = imread(<span class="string">"C:\\Users\\muyi\\Desktop\\pyproject\\123333.PNG"</span>);</span><br><span class="line">Mat gray，dst;</span><br><span class="line">cvtColor(src, gray, COLOR_BGR2GRAY); <span class="comment">// 图像灰度化</span></span><br><span class="line">LUT(gray, table, dst); <span class="comment">// 将灰度化的图像使用LUT映射</span></span><br><span class="line">imshow(<span class="string">"color"</span>, dst);</span><br><span class="line">imshow(<span class="string">"Second"</span>, gray);</span><br><span class="line">waitKey(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p><img src="/images/7.png" alt="1559921508811"></p><p>对三通道彩色图做映射</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/imgcodecs.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Mat <span class="title">table</span><span class="params">(<span class="number">1</span>, <span class="number">256</span>, CV_8UC3)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) &#123;</span><br><span class="line"><span class="comment">//img.at&lt;cv::Vec3b&gt;(row,col) 对各个通道的灰度映射如下</span></span><br><span class="line">table.at&lt;cv::Vec3b&gt;(<span class="number">0</span>,i)[<span class="number">1</span>] =  <span class="number">255</span> - i; <span class="comment">// B</span></span><br><span class="line">table.at&lt;cv::Vec3b&gt;(<span class="number">0</span>, i)[<span class="number">0</span>] = <span class="number">255</span> - i;<span class="comment">// *5 &lt;0 ? 0: 255 - i*5; // G</span></span><br><span class="line">table.at&lt;cv::Vec3b&gt;(<span class="number">0</span>, i)[<span class="number">2</span>] = <span class="number">255</span> - i;<span class="comment">// *15&lt;0 ? 0: 255 - i*15; //R</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Mat src = imread(<span class="string">"C:\\Users\\muyi\\Desktop\\pyproject\\123333.PNG"</span>);</span><br><span class="line">Mat dst;</span><br><span class="line">LUT(src, table, dst);</span><br><span class="line">imshow(<span class="string">"src"</span>, src);</span><br><span class="line">imshow(<span class="string">"color"</span>, dst);</span><br><span class="line">waitKey(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="/images/8.png" alt="1559922056587"></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> opencv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenCV 4.0 Notes (一) 图像与视频的读写</title>
      <link href="/2019/06/09/%E7%AC%94%E8%AE%B0(%E4%B8%80)%20-%20%E5%9B%BE%E5%83%8F%E8%A7%86%E9%A2%91%E7%9A%84%E8%AF%BB%E5%86%99%E4%B8%8E%E6%98%BE%E7%A4%BA/"/>
      <url>/2019/06/09/%E7%AC%94%E8%AE%B0(%E4%B8%80)%20-%20%E5%9B%BE%E5%83%8F%E8%A7%86%E9%A2%91%E7%9A%84%E8%AF%BB%E5%86%99%E4%B8%8E%E6%98%BE%E7%A4%BA/</url>
      
        <content type="html"><![CDATA[<p>opencv学习笔记（一）图像视频读写</p><a id="more"></a><h1 id="读取图片"><a href="#读取图片" class="headerlink" title="读取图片"></a>读取图片</h1><p>[==文档地址==][<a href="https://docs.opencv.org/4.0.0/d4/da8/group__imgcodecs.html#ga288b8b3da0892bd651fce07b3bbd3a56]" target="_blank" rel="noopener">https://docs.opencv.org/4.0.0/d4/da8/group__imgcodecs.html#ga288b8b3da0892bd651fce07b3bbd3a56]</a> </p><h2 id="imread方法"><a href="#imread方法" class="headerlink" title="imread方法"></a>imread方法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Mat <span class="title">imread</span><span class="params">(<span class="keyword">const</span> String &amp; filename ,<span class="keyword">int</span> flags=IMREAD_COLOR)</span></span>;</span><br></pre></td></tr></table></figure><p>imread读取图像，返回Mat对象，两个参数，第一个是文件名，支持位图bmp、dib，JPEG图像，PNG，webp，pbm，pgm,ppm,TIFF等多种图像，读取失败则返回空矩阵 </p><p>第二个读取方式，默认值是1 flag = 1  返回三通道彩色图    flag = 0 灰度图   flag = -1 原图带alpha通道</p><p>如果返回三通道，编码顺序是BGR。支持读取的图像格式如下</p><blockquote><p>Currently, the following file formats are supported:</p><ul><li>Windows bitmaps - <em>.bmp, </em>.dib (always supported)</li><li>JPEG files - <em>.jpeg, </em>.jpg, <em>.jpe (see the </em>Note* section)</li><li>JPEG 2000 files - <em>.jp2 (see the </em>Note* section)</li><li>Portable Network Graphics - <em>.png (see the </em>Note* section)</li><li>WebP - <em>.webp (see the </em>Note* section)</li><li>Portable image format - <em>.pbm, </em>.pgm, <em>.ppm </em>.pxm, *.pnm (always supported)</li><li>Sun rasters - <em>.sr, </em>.ras (always supported)</li><li>TIFF files - <em>.tiff, </em>.tif (see the <em>Note</em> section)</li><li>OpenEXR Image files - <em>.exr (see the </em>Note* section)</li><li>Radiance HDR - <em>.hdr, </em>.pic (always supported)</li><li>Raster and Vector geospatial data supported by GDAL (see the <em>Note</em> section)</li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 图片路径 可以是/或者//或者\\或者 /、//、\\混合；但不能是单独的反斜杠 \</span></span><br><span class="line">Mat src = imread(<span class="string">"C:/Users/muyi/Pictures/pic/5503.jpg"</span>);</span><br><span class="line">imshow(<span class="string">"input"</span>, src);</span><br><span class="line">waitKey(<span class="number">0</span>);</span><br><span class="line">destroyAllWindows();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line">img = cv2.imread(filename,flags)  <span class="comment"># 返回array矩阵，读取失败则是nonetype</span></span><br></pre></td></tr></table></figure><h2 id="图片读取出错处理"><a href="#图片读取出错处理" class="headerlink" title="图片读取出错处理"></a>图片读取出错处理</h2><p>文件损坏、不存在、权限错误等问题导致读取图片失败，程序==不会报错==，但是返回的是空矩阵，不处理后续使用可能会出错。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Mat src = imread(<span class="string">"test.png"</span>);</span><br><span class="line"><span class="keyword">if</span> (src.empty()) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"could not load image...\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">src = cv2.imread(<span class="string">"test.png"</span>)</span><br><span class="line"><span class="comment"># 断言判断读取是否成功</span></span><br><span class="line"><span class="keyword">assert</span> type(src)==<span class="literal">None</span>,<span class="string">"load image error"</span></span><br><span class="line"><span class="comment"># 或者if语句判断</span></span><br><span class="line"><span class="keyword">if</span> src.all() == <span class="literal">None</span>:  <span class="comment">#</span></span><br><span class="line">    print(<span class="string">"load image error"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者 try,自定义异常</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_img</span><span class="params">(path)</span>:</span></span><br><span class="line">    img = cv2.imread(path)</span><br><span class="line">    <span class="keyword">if</span> img == <span class="literal">None</span>:   <span class="comment"># 用type(img)==None 无效</span></span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">"load image error"</span>)</span><br><span class="line">    <span class="keyword">return</span> img</span><br><span class="line"><span class="keyword">try</span> :</span><br><span class="line">    read_img(<span class="string">'eee.png'</span>)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> err:</span><br><span class="line">    print(err)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    后续处理</span><br></pre></td></tr></table></figure><h2 id="读取的图片属性"><a href="#读取的图片属性" class="headerlink" title="读取的图片属性"></a>读取的图片属性</h2><p>==C++版本，读取图像以Mat类形式存储，Python版本以np.array形式存储==</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Mat img = imread(<span class="string">"C:\Users\muyi\Pictures\pic\5503.jpg"</span>);</span><br><span class="line"><span class="comment">// Mat类的部分属性</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"dims:"</span> &lt;&lt; img.dims &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 矩阵的维度</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"rows:"</span> &lt;&lt; img.rows &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 矩阵的行数</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"cols:"</span> &lt;&lt; img.cols &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 矩阵列数</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"channels:"</span> &lt;&lt; img.channels() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 图像通道数</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"type:"</span> &lt;&lt; img.type() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 表示了矩阵中元素的类型以及矩阵的通道个数</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"depth:"</span> &lt;&lt; img.depth() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 深度</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"elemSize:"</span> &lt;&lt; img.elemSize() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 矩阵一个元素占用的字节数</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"elemSize1:"</span> &lt;&lt; img.elemSize1() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//矩阵元素一个通道占用的字节数= elemSize / channels</span></span><br><span class="line"><span class="comment">// type为 CV_16SC3，那么elemSize = 3 * 16 / 8 = 6 bytes</span></span><br></pre></td></tr></table></figure><p>图像矩阵的type取值：[参考博客]<a href="https://blog.csdn.net/zang141588761/article/details/50340709" target="_blank" rel="noopener">https://blog.csdn.net/zang141588761/article/details/50340709</a></p><p>它是一系列的预定义的常量，其命名规则为CV_(位数）+（数据类型）+（通道数）U（unsigned integer）表示的是无符号整数，S（signed integer）是有符号整数，F（float）是浮点数。  C1，C2，C3，C4则表示通道是1,2,3,4  </p><p>==type一般是在创建Mat对象时设定==，如果要取得Mat的元素类型，则无需使用type，使用depth</p><p>depth 矩阵中元素的一个通道的数据类型，这个值和type是相关的。例如 type为 CV_16SC2，一个2通道的16位的有符号整数。那么，depth则是CV_16S。depth也是一系列的预定义值，<br>将type的预定义值去掉通道信息就是depth值:   CV_8U CV_8S CV_16U CV_16S CV_32S CV_32F CV_64F</p><p>表1. Mat对象type的取值表</p><table><thead><tr><th>CV_8UC1</th><th>CV_8UC2</th><th>CV_8UC3</th><th>CV_8UC4</th></tr></thead><tbody><tr><td>CV_8SC1</td><td>CV_8SC2</td><td>CV_8SC3</td><td>CV_8SC4</td></tr><tr><td>CV_16UC1</td><td>CV_16UC2</td><td>CV_16UC3</td><td>CV_16UC4</td></tr><tr><td>CV_16SC1</td><td>CV_16SC2</td><td>CV_16SC3</td><td>CV_16SC4</td></tr><tr><td>CV_32SC1</td><td>CV_32SC2</td><td>CV_32SC3</td><td>CV_32SC4</td></tr><tr><td>CV_32FC1</td><td>CV_32FC2</td><td>CV_32FC3</td><td>CV_32FC4</td></tr><tr><td>CV_64FC1</td><td>CV_64FC2</td><td>CV_64FC3</td><td>CV_64FC4</td></tr></tbody></table><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Mat <span class="title">img</span><span class="params">(<span class="number">3</span>, <span class="number">4</span>, CV_16UC4, Scalar_&lt;uchar&gt;(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>))</span></span>;<span class="comment">//3X4的矩阵 16位无符号4通道</span></span><br><span class="line"><span class="comment">//Scalar_是一个模板向量，用来初始化矩阵的每个像素，因为矩阵具有4个通道，Scalar_有四个值。</span></span><br></pre></td></tr></table></figure><p>python版本cv图像格式，type(img) = numpy.ndarray 因此，它具有array的一切属性和方法，而不同于c++版本中Mat的deepth()、type()等写法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">"test.png"</span>)</span><br><span class="line">print(img.shape) <span class="comment"># [M,N,K] 行 列 通道数</span></span><br><span class="line">print(img.size) <span class="comment"># M*N*K</span></span><br><span class="line"><span class="comment"># 一些特殊方法</span></span><br><span class="line">print(img.mean()) <span class="comment">#平均值 img.sum() 元素和 std()标准差 等等</span></span><br><span class="line">img = img.flatten()</span><br><span class="line">img = img.ravel()</span><br><span class="line">img = img.reshape()</span><br></pre></td></tr></table></figure><h1 id="写入图片"><a href="#写入图片" class="headerlink" title="写入图片"></a>写入图片</h1><p>[==文档地址==][<a href="https://docs.opencv.org/4.0.0/d4/da8/group__imgcodecs.html#gabbc7ef1aa2edfaa87772f1202d67e0ce]" target="_blank" rel="noopener">https://docs.opencv.org/4.0.0/d4/da8/group__imgcodecs.html#gabbc7ef1aa2edfaa87772f1202d67e0ce]</a></p><h2 id="imwrite方法"><a href="#imwrite方法" class="headerlink" title="imwrite方法"></a>imwrite方法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> cv::imwrite(<span class="keyword">const</span> String &amp; filename, InputArray img , <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;params = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">retval = cv2.imwrite(filename, img[, params])</span><br></pre></td></tr></table></figure><p>支持写入的图像格式与imread一致。8位单通道或3通道BGR编码数据才可以使用该函数。</p><p>16位无符号图像数据，可以保存为PNG, JPEG2000 和TIFF</p><p>32位浮点图像数据，可以保存为TIFF，OpenEXR，Radiance HDR格式</p><p>3通道32位浮点图像数据被保存TIFF格式，则存储为高动态范围图像（High-Dynamic Range，HDR），每个像素4字节</p><p>8位带透明度的PNG图像保存时需要创建第四个通道，最终数据格式是BGRA</p><p>==对于非上述类型数据，可以通过mat.convertTo函数进行转换，然后写入图像文件==</p><blockquote><p>In general, only 8-bit single-channel or 3-channel (with ‘BGR’ channel order) images can be saved using this function</p><ul><li>16-bit unsigned (CV_16U) images can be saved in the case of PNG, JPEG 2000, and TIFF formats</li><li>32-bit float (CV_32F) images can be saved in TIFF, OpenEXR, and Radiance HDR formats; 3-channel (CV_32FC3) TIFF images will be saved using the LogLuv high dynamic range encoding (4 bytes per pixel)</li><li>PNG images with an alpha channel can be saved using this function. To do this, create 8-bit (or 16-bit) 4-channel image BGRA, where the alpha channel goes last. Fully transparent pixels should have alpha set to 0, fully opaque pixels should have alpha set to 255/65535 (see the code sample below).</li></ul></blockquote><h2 id="带透明度的png图像"><a href="#带透明度的png图像" class="headerlink" title="带透明度的png图像"></a>带透明度的png图像</h2><p>c++源码，创建带透明度的PNG图像。(出自cv文档imwrite函数说明)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/imgcodecs.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createAlphaMat</span><span class="params">(Mat &amp;mat)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CV_Assert(mat.channels() == <span class="number">4</span>); <span class="comment">// 等同于c++里面的assert,条件为false返回错误信息</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mat.rows; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; mat.cols; ++j)</span><br><span class="line">        &#123;  <span class="comment">// 行列遍历进行赋值  Vec是OpenCV定义的向量模板类</span></span><br><span class="line">            Vec4b&amp; bgra = mat.at&lt;Vec4b&gt;(i, j);</span><br><span class="line">            bgra[<span class="number">0</span>] = UCHAR_MAX; <span class="comment">// Blue define UCHAR_MAX 0xff </span></span><br><span class="line">            bgra[<span class="number">1</span>] = saturate_cast&lt;uchar&gt;((<span class="keyword">float</span> (mat.cols - j)) / ((<span class="keyword">float</span>)mat.cols) * UCHAR_MAX); <span class="comment">// Green  saturate_cast&lt;unchar&gt;是一个防止颜色操作溢出的函数，数据小于0置0；大于255置255</span></span><br><span class="line">            bgra[<span class="number">2</span>] = saturate_cast&lt;uchar&gt;((<span class="keyword">float</span> (mat.rows - i)) / ((<span class="keyword">float</span>)mat.rows) * UCHAR_MAX); <span class="comment">// Red</span></span><br><span class="line">            bgra[<span class="number">3</span>] = saturate_cast&lt;uchar&gt;(<span class="number">0.5</span> * (bgra[<span class="number">1</span>] + bgra[<span class="number">2</span>])); <span class="comment">// Alpha</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Create mat with alpha channel</span></span><br><span class="line">    <span class="function">Mat <span class="title">mat</span><span class="params">(<span class="number">480</span>, <span class="number">640</span>, CV_8UC4)</span></span>;</span><br><span class="line">    createAlphaMat(mat); <span class="comment">// 创建矩阵数据</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; compression_params;</span><br><span class="line">    compression_params.push_back(IMWRITE_PNG_COMPRESSION); <span class="comment">// 枚举值16</span></span><br><span class="line">    compression_params.push_back(<span class="number">9</span>);</span><br><span class="line">    <span class="keyword">bool</span> result = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        result = imwrite(<span class="string">"alpha.png"</span>, mat, compression_params);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (<span class="keyword">const</span> cv::Exception&amp; ex)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Exception converting image to PNG format: %s\n"</span>, ex.what());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (result)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Saved PNG file with alpha data.\n"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"ERROR: Can't save PNG file.\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> result ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>python实现上述功能</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">img = np.zeros((<span class="number">480</span>,<span class="number">640</span>,<span class="number">4</span>),np.float)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">saturate</span><span class="params">(num)</span>:</span>  <span class="comment">## 不清楚cv2防止颜色溢出函数，因此自定义即可</span></span><br><span class="line">    <span class="keyword">if</span> num &gt;<span class="number">255.0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">255.0</span></span><br><span class="line">    <span class="keyword">if</span> num &lt;<span class="number">0.0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> num</span><br><span class="line">rows = img.shape[<span class="number">0</span>]</span><br><span class="line">cols = img.shape[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(rows):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(cols):</span><br><span class="line">        temp = img[i][j] <span class="comment"># 像素[i][j]位置的四个通道数据</span></span><br><span class="line">        temp[<span class="number">0</span>] = <span class="number">0xff</span></span><br><span class="line">        temp[<span class="number">1</span>] = saturate((cols-j)/rows*<span class="number">255.0</span>)</span><br><span class="line">        temp[<span class="number">2</span>] = saturate((rows-j) /cols *<span class="number">255.0</span>)</span><br><span class="line">        temp[<span class="number">3</span>] = saturate(temp[<span class="number">2</span>]+temp[<span class="number">1</span>])  <span class="comment">#可以看到不同透明度，显示效果不一样</span></span><br><span class="line">cv2.imwrite(<span class="string">'alpha.png'</span>,img)</span><br></pre></td></tr></table></figure><p><img src="/images/9.png" alt="1559393771424"></p><h1 id="读取视频"><a href="#读取视频" class="headerlink" title="读取视频"></a>读取视频</h1><p>videoCapture结构体，可以读取文件视频、网页视频流和摄像头的数据。</p><p>[文档地址][<a href="https://docs.opencv.org/4.0.0/d8/dfe/classcv_1_1VideoCapture.html#a57c0e81e83e60f36c83027dc2a188e80]" target="_blank" rel="noopener">https://docs.opencv.org/4.0.0/d8/dfe/classcv_1_1VideoCapture.html#a57c0e81e83e60f36c83027dc2a188e80]</a></p><h2 id="capture结构体"><a href="#capture结构体" class="headerlink" title="capture结构体"></a>capture结构体</h2><p>函数原型 ==VideoCapture (const String &amp;filename, int apiPreference=CAP_ANY)==</p><p>==cv2.VideoCapture(filename[, apiPreference])==</p><p>Opens a video file or a capturing device or an IP video stream for video capturing with API Preference</p><p>第一个参数是数据流或视频路径，第二个是API设置，读取的摄像头编号，默认CAP_ANY=0,自动检测摄像头。多个摄像头时，使用索引0,1,2，…进行编号调用摄像头。 apiPreference = -1时单独出现窗口，选取相应编号摄像头</p><p>通常使用 ==bool isOpened()==判断是否打开视频或摄像头成功。</p><h2 id="下一帧与释放"><a href="#下一帧与释放" class="headerlink" title="下一帧与释放"></a>下一帧与释放</h2><p>cap &gt;&gt; frame或者 ==cap.read(frame)==读取下一帧，函数定义是CV_WRAP virtual bool read(OutputArray image);读取帧失败会返回布尔值false，因此可以进行判断</p><p>==视频帧读取的 read 、grab 、retrieve三种方式==：</p><p>retrieve速度比grab慢很多，有时可以通过grab跳过不需要的帧，而不需要用read解码每一帧。</p><ol><li>cap.read(frame)  结合grab和retrieve的功能，抓取下一帧并解码</li><li>cap.grap() 从设备或视频获取下一帧，获取成功返回true否则false</li><li>cap.retrieve(frame) 在grab后使用，对获取到的帧进行解码，也返回true或false</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">char</span>**)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Mat frame; <span class="comment">//定义帧</span></span><br><span class="line">VideoCapture cap;</span><br><span class="line"><span class="keyword">int</span> deviceID = <span class="number">0</span>;             <span class="comment">// 0 = open default camera</span></span><br><span class="line"><span class="keyword">int</span> apiID = cv::CAP_ANY;      <span class="comment">// 0 = autodetect default API</span></span><br><span class="line">    </span><br><span class="line">cap.open(deviceID + apiID);  <span class="comment">//打开摄像头</span></span><br><span class="line"><span class="comment">// check if we succeeded</span></span><br><span class="line"><span class="keyword">if</span> (!cap.isOpened()) &#123;</span><br><span class="line"><span class="built_in">cerr</span> &lt;&lt; <span class="string">"ERROR! Unable to open camera\n"</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//--- GRAB AND WRITE LOOP</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Start grabbing"</span> &lt;&lt; <span class="built_in">endl</span></span><br><span class="line">&lt;&lt; <span class="string">"Press any key to terminate"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (;;)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// wait for a new frame from camera and store it into 'frame'</span></span><br><span class="line">cap.read(frame);  <span class="comment">//读取下一帧，并可以返回读取成功与否</span></span><br><span class="line">        <span class="comment">//等价于 cap &gt;&gt; frame 同时等价于 cap.grab();cap.retrieve(frame);</span></span><br><span class="line"><span class="keyword">if</span> (frame.empty()) &#123;</span><br><span class="line"><span class="built_in">cerr</span> &lt;&lt; <span class="string">"ERROR! blank frame grabbed\n"</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">imshow(<span class="string">"Live"</span>, frame);</span><br><span class="line"><span class="keyword">if</span> (waitKey(<span class="number">100</span>) &gt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// the camera will be deinitialized automatically in VideoCapture destructor</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line">cap = cv2.VideoCapture(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> cap.isOpened():</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        ret, prev = cap.read()  <span class="comment"># ret是读取状态，prev下一帧</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        等价于</span></span><br><span class="line"><span class="string">       if cap.grab():</span></span><br><span class="line"><span class="string">        ret, prev = cap.retrieve()</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> ret==<span class="literal">True</span>:</span><br><span class="line">            cv2.imshow(<span class="string">'video'</span>, prev)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> cv2.waitKey(<span class="number">20</span>)==<span class="number">27</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><p>release()在使用完后进行手动释放capture对象</p><h2 id="读取视频属性-get-方法"><a href="#读取视频属性-get-方法" class="headerlink" title="读取视频属性 get()方法"></a>读取视频属性 get()方法</h2><p>函数原型：==double cv::VideoCapture::get(int  propId)==</p><p>==retval=cv2.VideoCapture.get(propId)==</p><p>cv2.VideoCapture.get(0)     视频文件的当前位置（播放）以毫秒为单位<br>cv2.VideoCapture.get(1)     基于以0开始的被捕获或解码的帧索引<br>cv2.VideoCapture.get(2)     视频文件的相对位置（播放）：0=电影开始，1=影片的结尾。<br>cv2.VideoCapture.get(3)     在视频流的帧的宽度<br>cv2.VideoCapture.get(4)     在视频流的帧的高度<br>cv2.VideoCapture.get(5)     帧速率<br>cv2.VideoCapture.get(6)     编解码的4字-字符代码<br>cv2.VideoCapture.get(7)     视频文件中的帧数<br>cv2.VideoCapture.get(8)     返回对象的格式<br>cv2.VideoCapture.get(9)     返回后端特定的值，该值指示当前捕获模式<br>cv2.VideoCapture.get(10)     图像的亮度(仅适用于照相机)<br>cv2.VideoCapture.get(11)     图像的对比度(仅适用于照相机)<br>cv2.VideoCapture.get(12)     图像的饱和度(仅适用于照相机)<br>cv2.VideoCapture.get(13)     色调图像(仅适用于照相机)<br>cv2.VideoCapture.get(14)     图像增益(仅适用于照相机)（Gain在摄影中表示白平衡提升）<br>cv2.VideoCapture.get(15)     曝光(仅适用于照相机)<br>cv2.VideoCapture.get(16)     指示是否应将图像转换为RGB布尔标志<br>cv2.VideoCapture.get(17)     × 暂时不支持<br>cv2.VideoCapture.get(18)     立体摄像机的矫正标注（目前只有DC1394 v.2.x后端支持这个功能）</p><h1 id="写入视频"><a href="#写入视频" class="headerlink" title="写入视频"></a>写入视频</h1><p>函数文档<a href="https://docs.opencv.org/4.0.0/dd/d9e/classcv_1_1VideoWriter.html#ad59c61d8881ba2b2da22cff5487465b5" target="_blank" rel="noopener">https://docs.opencv.org/4.0.0/dd/d9e/classcv_1_1VideoWriter.html#ad59c61d8881ba2b2da22cff5487465b5</a></p><h2 id="VideoWriter类"><a href="#VideoWriter类" class="headerlink" title="VideoWriter类"></a>VideoWriter类</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv::VideoWriter::VideoWriter(<span class="keyword">const</span> String &amp; filename,<span class="keyword">int</span> fourcc,<span class="keyword">double</span> fps,Size frameSize,<span class="keyword">bool</span> isColor = <span class="literal">true</span> )  <span class="comment">// isColor</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cv2.VideoWriter(filename, fourcc, fps, frameSize[, isColor])</span><br><span class="line">cv.VideoWriter(filename, apiPreference, fourcc, fps, frameSize[, isColor])</span><br></pre></td></tr></table></figure><p>写入视频需要指定视频的==帧率fps== , ==帧尺寸framesize== ,==编码格式fourcc==</p><p>framesize的大小应该与写入的每一帧图像尺寸大小一致</p><p>输出文件类型要与编码类型一致</p><p>几种常用视频编解码器 </p><p>生成文件占用空间最小的编码方式是MPEG-4.2 。在VideoWriter类的构造函数参数为CV_FOURCC(‘M’, ‘P’, ‘4’, ‘2’) 。</p><p>最大的是MPEG-1，对应在VideoWriter类的构造函数参数为CV_FOURCC(‘P’,’I’,’M’,’1’) ，所占磁盘空间是前者的5.7倍。</p><p>fourcc定义</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> cv::VideoWriter::fourcc(<span class="keyword">char</span> c1,<span class="keyword">char</span> c2,<span class="keyword">char</span> c3,<span class="keyword">char</span> c4 )</span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">retval  =  cv2.VideoWriter_fourcc(  c1, c2, c3, c4  )</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cv2.VideoWriter_fourcc(<span class="string">'m'</span>,<span class="string">'p'</span>,<span class="string">'a'</span>,<span class="string">'v'</span>) AVI或者mp4文件 </span><br><span class="line">cv2.VideoWriter_fourcc(<span class="string">'M'</span>,<span class="string">'J'</span>,<span class="string">'P'</span>,<span class="string">'G'</span>) avi或者mp4 motion-jpeg编码</span><br><span class="line">cv2.VideoWriter_fourcc(<span class="string">'P'</span>,<span class="string">'I'</span>,<span class="string">'M'</span>,<span class="string">'I'</span>) MPEG<span class="number">-1</span>编码 AVI文件</span><br><span class="line">cv2.VideoWriter_fourcc(<span class="string">'X'</span>,<span class="string">'V'</span>,<span class="string">'I'</span>,<span class="string">'D'</span>) MPEG<span class="number">-4</span>编码 AVI文件</span><br><span class="line">cv2.VideoWriter_fourcc(<span class="string">'T'</span>,<span class="string">'H'</span>,<span class="string">'E'</span>,<span class="string">'O'</span>)  Ogg Vorbis 后缀名 ogv</span><br><span class="line">cv2.VideoWriter_fourcc(<span class="string">'F'</span>,<span class="string">'L'</span>,<span class="string">'V'</span>,<span class="string">'1'</span>)  flash视频，后缀名 flv</span><br></pre></td></tr></table></figure><p>c++创建writer对象和写入图像帧有两种方式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;opencv2/video.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//方法1  定义对象，然后使用open方法开启  opencv2/videoio.hpp定义了fourcc</span></span><br><span class="line">VideoWriter out;</span><br><span class="line"><span class="keyword">int</span> fourcc = out.fourcc(<span class="string">'M'</span>, <span class="string">'J'</span>,<span class="string">'P'</span>, <span class="string">'G'</span>);</span><br><span class="line">out.open(<span class="string">"video.mp4"</span>, fourcc, <span class="number">30.0</span>, cv::Size(<span class="number">640</span>, <span class="number">480</span>), <span class="comment">// 单帧图片分辨率为 640x480</span></span><br><span class="line"><span class="literal">true</span> <span class="comment">// 只输入彩色图</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 方法2  构造函数*/</span>  </span><br><span class="line">   <span class="function">VideoWriter <span class="title">out</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">       <span class="keyword">const</span> <span class="built_in">string</span>&amp; filename, <span class="comment">// 输入文件名</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">int</span> fourcc, <span class="comment">// 编码形式，</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">double</span> fps, <span class="comment">// 输出视频帧率</span></span></span></span><br><span class="line"><span class="function"><span class="params">cv::Size frame_size, <span class="comment">// 单帧图片的大小</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">bool</span> is_color = <span class="literal">true</span> <span class="comment">// 如果是false,可传入灰度图像 </span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>python将文件夹中所有图片写入视频</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">im_dir = <span class="string">'det'</span>  <span class="comment">#图片路径</span></span><br><span class="line">video_dir = <span class="string">'out4.avi'</span> <span class="comment">#输出视频路径</span></span><br><span class="line">fps = <span class="number">23.977</span> <span class="comment">#输出视频路径</span></span><br><span class="line"><span class="comment">#图片数 </span></span><br><span class="line">num = <span class="number">888</span></span><br><span class="line">img_size = (<span class="number">500</span>,<span class="number">300</span>)</span><br><span class="line"><span class="comment">#fourcc = cv2.cv.CV_FOURCC('M','J','P','G')#opencv2.4</span></span><br><span class="line">fourcc = cv2.VideoWriter_fourcc(<span class="string">'M'</span>,<span class="string">'J'</span>,<span class="string">'P'</span>,<span class="string">'G'</span>) <span class="comment">#opencv3.0之后的写法</span></span><br><span class="line">videoWriter = cv2.VideoWriter(video_dir, fourcc, fps, img_size) <span class="comment">#定义视频写入类</span></span><br><span class="line"></span><br><span class="line">pics = os.listdir(im_dir)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(num):</span><br><span class="line">    im_name = os.path.join(im_dir, str(i)+<span class="string">'.jpg'</span>)</span><br><span class="line">    frame = cv2.imread(im_name)</span><br><span class="line">    <span class="keyword">if</span> type(frame) != <span class="literal">None</span>:</span><br><span class="line">        videoWriter.write(frame) <span class="comment">#写入帧</span></span><br><span class="line"></span><br><span class="line">videoWriter.release()</span><br><span class="line"><span class="keyword">print</span> (<span class="string">'finish'</span>)</span><br></pre></td></tr></table></figure><h1 id="显示窗口Windows"><a href="#显示窗口Windows" class="headerlink" title="显示窗口Windows"></a>显示窗口Windows</h1><p>可以自定义窗口显示图像的模式</p><h2 id="窗口函数"><a href="#窗口函数" class="headerlink" title="窗口函数"></a>窗口函数</h2><p>[官方文档][<a href="https://docs.opencv.org/4.0.0/d7/dfc/group__highgui.html#ggabf7d2c5625bc59ac130287f925557ac3acf621ace7a54954cbac01df27e47228f]" target="_blank" rel="noopener">https://docs.opencv.org/4.0.0/d7/dfc/group__highgui.html#ggabf7d2c5625bc59ac130287f925557ac3acf621ace7a54954cbac01df27e47228f]</a></p><p>==函数原型==   void nameWindow(const string&amp; winname,int flags = WINDOW_AUTOSIZE) ;第一个参数是窗口名字，第二个是显示模式，flag <del>默认值</del> 是window_autosize</p><center>居中</center><ol><li>WINDOW_AUTOSIZE 窗口大小自动适应图片大小，并且不可手动更改</li><li>WINDOW_NORMAL 用户可以改变这个窗口大小</li><li>WINDOW_OPENGL 窗口创建的时候会支持OpenGL ,且可以更改窗口大小</li></ol><p>定义窗口名称，imshow时可以指定让图像在该窗口显示</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">namedWindow(<span class="string">"input"</span>, WINDOW_AUTOSIZE);</span><br><span class="line">imshow(<span class="string">"input"</span>, src);</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cv2.namedWindow(<span class="string">"input"</span>, cv2.WINDOW_AUTOSIZE)</span><br><span class="line">cv2.imshow(<span class="string">"input"</span>, src)</span><br></pre></td></tr></table></figure><h2 id="一个窗口显示多张图片"><a href="#一个窗口显示多张图片" class="headerlink" title="一个窗口显示多张图片"></a>一个窗口显示多张图片</h2><p>另一种方法是matplotlib</p><p>OpenCV一个窗口只能显示一张图片。但可以通过组合多张图，实现多张图在一个窗口的视觉效果。</p><h3 id="Python-numpy组合"><a href="#Python-numpy组合" class="headerlink" title="Python  numpy组合"></a>Python  numpy组合</h3><p>用np.hstack或者np.vstack组合矩阵  ==若是要让各个图片之间显示间隔，可以插入0或255的列做间隔==</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#图1</span></span><br><span class="line">img = cv2.imread(<span class="string">r'C:\Users\muyi\Pictures\pic\489321.jpg'</span>)</span><br><span class="line"><span class="comment">#图2</span></span><br><span class="line">img2 = cv2.imread(<span class="string">r'C:\Users\muyi\Pictures\pic\489323.jpg'</span>)</span><br><span class="line"><span class="comment">#图集</span></span><br><span class="line">imgs = np.hstack([img,img2])</span><br><span class="line"><span class="comment">#展示多个</span></span><br><span class="line">cv2.imshow(<span class="string">"mutil_pic"</span>, imgs)</span><br><span class="line"><span class="comment">#等待关闭</span></span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><img src="/images/10.png" alt="1559227778334"></p><p>==OpenCV一个窗口显示多个图片的注意事项==：</p><p>读入的多个图片必须具有==相同的尺寸、通道数==。若是彩图、灰度图同时显示，会出现窗口黑屏现象</p><h3 id="matplotlib划分窗口显示多张图："><a href="#matplotlib划分窗口显示多张图：" class="headerlink" title="matplotlib划分窗口显示多张图："></a>matplotlib划分窗口显示多张图：</h3><p>利用 plt.subplot(m,n,k)划分窗口即可，类似matlab的绘图，而且各个窗口可以显示不同格式的图像</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> opencv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vs2015配置opencv</title>
      <link href="/2019/06/09/%E7%AC%94%E8%AE%B0(%E9%9B%B6)%20-%20vs2015%E9%85%8D%E7%BD%AEopencv4.0.0/"/>
      <url>/2019/06/09/%E7%AC%94%E8%AE%B0(%E9%9B%B6)%20-%20vs2015%E9%85%8D%E7%BD%AEopencv4.0.0/</url>
      
        <content type="html"><![CDATA[<p>opencv4安装过程</p><a id="more"></a><h2 id="OpenCV"><a href="#OpenCV" class="headerlink" title="OpenCV"></a>OpenCV</h2><h2 id="https-opencv-org-releases-下载对应版本的exe"><a href="#https-opencv-org-releases-下载对应版本的exe" class="headerlink" title="https://opencv.org/releases/  下载对应版本的exe"></a><a href="https://opencv.org/releases/" target="_blank" rel="noopener">https://opencv.org/releases/</a>  下载对应版本的exe</h2><p>双击可以解压到指定文件夹，出现==bulid== 和==sources==文件夹</p><p>vs2015创建win32控制台程序，空项目。创建一个cpp源文件。 </p><p>工程是 debug x64</p><p>视图 -&gt; 其他窗口 -&gt; 属性管理器 </p><p> <img src="C:\Users\muyi\AppData\Roaming\Typora\typora-user-images\1559140306598.png" alt="1559140306598"></p><p>右键-属性  修改Debug x64的Microsoft.cpp.x64.user </p><p>通用属性 下的 vc++目录 ，包含目录和库目录需要增加</p><h1 id="包含目录增加"><a href="#包含目录增加" class="headerlink" title="包含目录增加"></a>包含目录增加</h1><p>E:\opencv4\opencv\build\include  和 E:\opencv4\opencv\build\include\opencv2</p><p>4.0.0版本之后的include文件夹下只有opencv2一个文件夹，之前的版本存在两个文件夹</p><h1 id="库目录增加："><a href="#库目录增加：" class="headerlink" title="库目录增加："></a>库目录增加：</h1><p>E:\opencv4\opencv\build\x64\vc14\lib</p><p>build/x64下面有vc14和vc15，vs2015选择的是vc14，vs2017选择的是vc15，将vc14下的lib文件夹路径添加到库目录即可</p><h1 id="链接器-输入-附加依赖向"><a href="#链接器-输入-附加依赖向" class="headerlink" title="链接器 - 输入 -附加依赖向"></a>链接器 - 输入 -附加依赖向</h1><p>需要增加lib文件，这个文件是vc14/lib下面的文件名</p><p>opencv_world400d.lib   d表示debug，另一个是release调试版本</p><p><img src="C:\Users\muyi\AppData\Roaming\Typora\typora-user-images\1559140888574.png" alt="1559140888574"></p><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">Mat src = imread(<span class="string">"C:/Users/muyi/Pictures/pic/5503.jpg"</span>);</span><br><span class="line">imshow(<span class="string">"input"</span>, src);</span><br><span class="line">waitKey(<span class="number">0</span>);</span><br><span class="line">destroyAllWindows();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> opencv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tf笔记（一）</title>
      <link href="/2019/06/09/tf%E5%9F%BA%E7%A1%80/"/>
      <url>/2019/06/09/tf%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>蒋子阳《TensorFlow深度学习算法原理与编程实战》的学习笔记(一)</p><a id="more"></a><p>环境：</p><p> Windows </p><p>TensorFlow 1.12 </p><p>GPU:1660ti</p><h1 id="TensorFlow-基础"><a href="#TensorFlow-基础" class="headerlink" title="TensorFlow 基础"></a>TensorFlow 基础</h1><p>tf以计算图为基础，整个计算过程包括 ① 构建图 ②执行图</p><p>TensorFlow首先创建一个骨架图，里面包含所有组件，此时没有数据和计算的产生，只有当会话执行时，数据进入图中进行流动，才有实际的结果产生。</p><p>tf的三个模型： </p><h2 id="计算图-–-计算模型"><a href="#计算图-–-计算模型" class="headerlink" title="计算图 – 计算模型"></a>计算图 – 计算模型</h2><p>图：是相互连接的实体的集合，通常称为节点node，节点通过边edge连接</p><p>TensorFlow中的图的每一个节点表示一个操作，并可应用在某个输入或生成传递给其他节点的输出</p><p>依赖关系：一个节点的输入取值于另一个节点的输出，那么这两个节点具有依赖关系。存在依赖关系的节点通过边相互连接。</p><p>张量(tensor)就是在边中流动(flow)的数据，这也是TensorFlow名称的由来。此外，存在一种不流动数据的边，它们起着依赖控制(control dependencies)作用，让起始节点执行完后才执行下一个目标节点，但中间没有数据传输。</p><h3 id="创建图"><a href="#创建图" class="headerlink" title="创建图"></a>创建图</h3><p>eg.定义一个简单的graph。 a b相乘得到c, d等于c的正弦，e等于b d的商</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line">a = tf.constant(<span class="number">5</span>,tf.float32)  <span class="comment"># 定义常量</span></span><br><span class="line">b = tf.constant(<span class="number">10</span>,tf.float32)</span><br><span class="line">print(b) <span class="comment"># Tensor("Const_1:0", shape=(), dtype=float32) 名称为const_1:0的tensor对象，类型是float32</span></span><br><span class="line">c = b*a  <span class="comment"># c = tf.mul(a,b)    c定义了这个乘法操作</span></span><br><span class="line">d = tf.sin(c)</span><br><span class="line">e = b / d</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess: <span class="comment"># 使用with语句打开会话可以保证计算完成后将会话自动关闭，否则使用sess.close()操作</span></span><br><span class="line">    fetches = [a,b,c,d,e]</span><br><span class="line">    out1 = sess.run(fetches) <span class="comment"># sess.run可以同时计算多个节点列表 sess.run参数称为fetches(提取)，将节点传入参数，用来计算该节点的值</span></span><br><span class="line">    <span class="comment"># TensorFlow仅利用依赖关系的集合来计算节点 例如，e依赖 b和d,则通过b d计算e</span></span><br><span class="line">    outs = sess.run(e)</span><br><span class="line">print(out1,type(out1),out1[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><p><img src="/images/1.png" alt="计算图"></p><h3 id="tf的计算图"><a href="#tf的计算图" class="headerlink" title="tf的计算图"></a>tf的计算图</h3><p>导入tf的时候，会自动生成一个空白图，后续的操作都与该默认图关联。</p><p>可以通过tf.Graph()创建一个新的空白图，并可以自定义操作与它关联。任何一个节点都可以通过graph属性查看是否属于某个图</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line">print(tf.get_default_graph()) <span class="comment">#默认空白图</span></span><br><span class="line">g = tf.Graph()</span><br><span class="line">print(g)</span><br><span class="line">a = tf.constant(<span class="number">5</span>)</span><br><span class="line">print(a.graph <span class="keyword">is</span> tf.get_default_graph()) <span class="comment"># 结果是true</span></span><br><span class="line">print(a.graph <span class="keyword">is</span> g) <span class="comment">#结果是false</span></span><br></pre></td></tr></table></figure><h3 id="多个计算图的管理"><a href="#多个计算图的管理" class="headerlink" title="多个计算图的管理"></a>多个计算图的管理</h3><p>with语句可以用于上下文管理，它设置了enter块和exit块，因此可以用它管理某个计算图，使用with语句和as_default()返回上下文管理器，指定某个计算图成为该部分的默认图，同时在该部分定义的计算关联与该图</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">g1 = tf.get_default_graph()</span><br><span class="line">g2 = tf.Graph()</span><br><span class="line">print(g1 <span class="keyword">is</span> tf.get_default_graph())  <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> g2.as_default():</span><br><span class="line">    print(g1 <span class="keyword">is</span> tf.get_default_graph()) <span class="comment"># False</span></span><br><span class="line"></span><br><span class="line">print(g1 <span class="keyword">is</span> tf.get_default_graph())  <span class="comment"># true</span></span><br></pre></td></tr></table></figure><h2 id="张量-–-数据模型"><a href="#张量-–-数据模型" class="headerlink" title="张量 – 数据模型"></a>张量 – 数据模型</h2><p>张量tensor类似于数组array，但是张量只保存了运算结果的属性，而没有保存它的具体数值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line">a = tf.constant([<span class="number">1.0</span>, <span class="number">2.0</span>],name = <span class="string">'a'</span> , dytpe= tf.float32)  <span class="comment"># 定义常量</span></span><br><span class="line">print(a) <span class="comment"># Tensor(""Const_1:0", shape=(2,), dtype=float32")</span></span><br></pre></td></tr></table></figure><p>每一个张量都具有操作op、维度shape和数据类型dtype三种属性。</p><h3 id="操作op"><a href="#操作op" class="headerlink" title="操作op"></a>操作op</h3><p>op是一个张量的名字，也算它的唯一标识符。计算图的每个节点都是一个运算，张量保存的是运算的属性，命名规则是“ node:src_output”。node是节点名称，如const、add、mul等，src_output表示该张量是节点的第几个输出，从0开始编号。</p><h3 id="维度shape"><a href="#维度shape" class="headerlink" title="维度shape"></a>维度shape</h3><p>类似array的维度，一维标量scalar、二维向量vector…..直至n维数组</p><h3 id="数据类型dtype"><a href="#数据类型dtype" class="headerlink" title="数据类型dtype"></a>数据类型dtype</h3><p>tf支持十四种类型 int8/16/32/64 、uint8、float32/64、布尔bool、复数complex64/128、字符串string和qint8/32、quint8</p><h2 id="会话-–-运行模型"><a href="#会话-–-运行模型" class="headerlink" title="会话 – 运行模型"></a>会话 – 运行模型</h2><p>完成数据和计算图的定义后需要使用会话session执行。</p><p>两种开启会话的方式：with语句更方便，自动关闭。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sess = tf.Session() <span class="comment"># 开启</span></span><br><span class="line">sess.run() <span class="comment"># 执行</span></span><br><span class="line">sess.close() <span class="comment"># 关闭</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    sess.run()</span><br></pre></td></tr></table></figure><h2 id="placeholder与变量Variable"><a href="#placeholder与变量Variable" class="headerlink" title="placeholder与变量Variable"></a>placeholder与变量Variable</h2><p>tf.constant定义的是计算图中的常量，可以通过placeholder和变量来定义可变数据。</p><h3 id="palceholder机制"><a href="#palceholder机制" class="headerlink" title="palceholder机制"></a>palceholder机制</h3><p>placeholder相当于在计算图中指定了一个位置，数据在程序运行时才给出。placeholder机制用于解决数据量过大的问题，可以将数据分批次传入节点，在编程时只需要传入holder位置即可，这样在有限的节点高效传入大量的数据。</p><p>函数原型 placeholder(dtype, shape=None, name=None)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = tf.placeholder(tf.float32,shape=(<span class="literal">None</span>,<span class="number">2</span>),name = <span class="string">"input"</span>)</span><br><span class="line">b = tf.placeholder(tf.float32,shape=(<span class="literal">None</span>,<span class="number">2</span>),name = <span class="string">"input"</span>)</span><br><span class="line">ans =a + b</span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    sess.run(ans, feed_dict=&#123;a:[<span class="number">1.0</span>,<span class="number">2.0</span>],</span><br><span class="line">                             b:[<span class="number">2.0</span>,<span class="number">3.0</span>]&#125;)</span><br><span class="line">print(ans)</span><br></pre></td></tr></table></figure><p>定义placeholder时，数据类型dtype必须给出且不可改变，shape若是给出时不确定可以用None，不给出的时候程序自动推断。</p><p>运行时通过sess.run的feed_dict参数传入holder的取值，它是一个字典数据，传入时的数据类型必须与placeholder定义时的类型一致，否则会报错。</p><h3 id="TensorFlow的变量"><a href="#TensorFlow的变量" class="headerlink" title="TensorFlow的变量"></a>TensorFlow的变量</h3><p>变量的作用是保存网络中的参数，对参数的更新就是对相应变量值的更新，使用Variable()声明变量，同时需要提供初始值。通常是采用随机分布赋初值。tf提供了正态分布、平均分布、伽马分布等多种类型。</p><p>此外变量的初值还可以是常量、其他变量的初值计算而来。z</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 声明一个变量并随机赋值，返回大小3×4 均值0 标准差1 满足正态分布的随机矩阵</span></span><br><span class="line">weights = tf.Variable(tf.random_normal([<span class="number">3</span>,<span class="number">4</span>], stddev=<span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>几种随机分布和常量初始化</p><table><thead><tr><th>函数名</th><th>功能</th><th>函数名</th><th>功能</th></tr></thead><tbody><tr><td>random_normal</td><td>正态分布</td><td>zeros</td><td>全0数组</td></tr><tr><td>truncate_normal</td><td>正态分布</td><td>ones</td><td>全1数组</td></tr><tr><td>random_uniform</td><td>平均分布</td><td>fill</td><td>全为给定值的数组</td></tr><tr><td>random_gamma</td><td>伽马分布</td><td>constant</td><td>给定值的常量</td></tr></tbody></table><p>获取一个变量的值通过initialized_value()方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bias = tf.Variable(tf.zeros([<span class="number">3</span>])) <span class="comment">#全为1的一维数组，长度3</span></span><br><span class="line">b1 = tf.Variable(bias.initialized_value()*<span class="number">3</span>) <span class="comment"># 使用bias的值乘3初始化bl</span></span><br></pre></td></tr></table></figure><p>批量初始化：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tf.global_variables_initializer() <span class="comment"># 初始化全部变量</span></span><br><span class="line">tf.initialize_all_variables() <span class="comment"># 较早版本tf的写法，1.12中仍存在，和上面的方法功能一样</span></span><br></pre></td></tr></table></figure><h3 id="变量和张量"><a href="#变量和张量" class="headerlink" title="变量和张量"></a>变量和张量</h3><p>变量在TensorFlow中是一个运算，对应tensorboard里面计算图的一个节点，这个运算的输出结果就是一个具有name、shape和type属性的张量。</p><p>变量在构建后数据类型就不能更改，但shape可以发生变化，需要设置validate_shape=False</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tf.assign(w1,w2,validate_shape=<span class="literal">False</span>) <span class="comment"># 将w2赋给w1，若是shape不一致，仍旧可以进行赋值</span></span><br></pre></td></tr></table></figure><h3 id="变量空间"><a href="#变量空间" class="headerlink" title="变量空间"></a>变量空间</h3><p>除了Variable()外，可以通过get_variable()创建或者获取变量，该函数的使用类似Variable，但有所不同。name参数此时必须指明，同时通过initializer参数指明初始化方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = tf.get_variable(name= <span class="string">"a"</span>, shape=[<span class="number">1</span>],initializer=tf.constant_initializer(<span class="number">1.0</span>))</span><br></pre></td></tr></table></figure><p>initializer参数的取值也包括常量和随机分布等初始化方法。</p><table><thead><tr><th>初始化函数</th><th>初始化为指定常量</th></tr></thead><tbody><tr><td>constant_initializer</td><td>正态分布初始化</td></tr><tr><td>random_normal_initializer</td><td>正态分布初始化</td></tr><tr><td>truncate_uniform_initializer</td><td>平均分布初始化</td></tr><tr><td>random_uint_scaling_initialize</td><td>平均分布但不影响输出数量级</td></tr><tr><td>random_gamma_initialize</td><td>伽马分布</td></tr><tr><td>zeros_initialize</td><td>全零初始化</td></tr><tr><td>ones_initialize</td><td>全1初始化</td></tr></tbody></table><p>variable_scope() 与name_scope(): 在变量空间使用get_variable获取已经创建过的变量</p><p>可以通过variable_scope指定一个变量空间，在该空间定义两个name相同的变量会报错。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.variable_scope(<span class="string">"one"</span>):</span><br><span class="line">    a1 = tf.get_variable(<span class="string">"a"</span>,[<span class="number">1</span>],initializer=tf.constant_initializer(<span class="number">1.0</span>))</span><br><span class="line">    </span><br><span class="line"><span class="keyword">with</span> tf.variable_scope(<span class="string">"one"</span>): <span class="comment">#报错 因为one空间已经存在一个name=a的变量，错误信息提示是否将reuse设置True</span></span><br><span class="line">    a2 = tf.get_variable(<span class="string">"a"</span>,[<span class="number">1</span>])    </span><br><span class="line"><span class="keyword">with</span> tf.variable_scope(<span class="string">"one"</span>,reuse=<span class="literal">True</span>):<span class="comment"># 不报错，因为reuse=True,可以重复使用，get_variable将获取one空间的name=a的变量赋值给a2</span></span><br><span class="line">    a3 = tf.get_variable(<span class="string">"a"</span>,[<span class="number">1</span>])</span><br><span class="line">    print(a1.name,a3.name) <span class="comment"># 输出是 one/a:0 one/a:0 变量空间内的变量name通常会带上空间名字作为前缀</span></span><br><span class="line"><span class="keyword">with</span> tf.variable_scope(<span class="string">"two"</span>,reuse=<span class="literal">True</span>): <span class="comment"># 报错，尽管reuse=True，但这是在变量空间two，函数只能在该对应空间选择定义过的变量，two空间没有name为a的变量</span></span><br><span class="line">    a4 = tf.get_variable(<span class="string">"a"</span>,[<span class="number">1</span>])</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tensorflow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo搭建个人博客</title>
      <link href="/2019/06/09/%E6%90%AD%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2/"/>
      <url>/2019/06/09/%E6%90%AD%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<p>我的第一篇博客，记录使用hexo搭建博客的过程。<br><a id="more"></a></p><p><a href="https://github.com/hexojs/hexo" target="_blank" rel="noopener">Hexo</a> 是一个基于node.js的静态博客框架，使用Markdown解析文章，具有速度快，搭建方便等特点。<br><blockquote><p>我的环境：<br>Windows x64<br>node.js v10.15.2<br>git v2.19.1</p></blockquote></p><h1 id="安装Node-js-和-git"><a href="#安装Node-js-和-git" class="headerlink" title="安装Node.js 和 git"></a>安装Node.js 和 git</h1><p>Node.js <a href="https://nodejs.org/en/" target="_blank" rel="noopener">https://nodejs.org/en/</a> 傻瓜式next安装即可<br>git <a href="https://git-scm.com/download/win" target="_blank" rel="noopener">https://git-scm.com/download/win</a> 选择对应版本安装即可</p><h1 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h1><p>选择一个目录存放，命令行打开 我的安装目录是 E:myblogfile</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-<span class="keyword">cli</span> -g</span><br></pre></td></tr></table></figure><h1 id="start"><a href="#start" class="headerlink" title="start"></a>start</h1><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo init blog #初始化博客 然后会在当前目录下生成一个blog（可以是任意名）文件夹</span><br><span class="line">cd blog  #进入博客文件夹</span><br><span class="line">npm install</span><br><span class="line">hexo<span class="built_in"> server </span># 打开本地服务</span><br></pre></td></tr></table></figure><p>浏览器打开 <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> 能够正确打开即可</p><h1 id="博客文件结构"><a href="#博客文件结构" class="headerlink" title="博客文件结构"></a>博客文件结构</h1><p>blog文件夹下的几个重要目录/文件</p><blockquote><p><strong>public</strong> ：hexo generate命令，输出的静态网页内容目录（通常不需要修改）<br><strong>deploy</strong> ：执行hexo deploy命令部署到GitHub上的内容目录<br><strong>source</strong> ：存放菜单的各个项目（tags、categories自己创建）、草稿（drafts）、已发布文章（posts)<br><strong>theme</strong> ：主题目录，默认主题landscape，自己下载的主题放在这里<br><strong>_config.yml</strong> ：站点配置文件，网站名称，副标题，描述，作者，语言，主题，部署等等参数。这个文件下面会做较为详细的介绍。</p></blockquote><h2 id="站点配置"><a href="#站点配置" class="headerlink" title="站点配置"></a>站点配置</h2><p>###Github 创建仓库<br>在github上创建新的Repository（没有github账号请创建）,名字为<code>&lt;blog name&gt;.github.io</code><br>当然 blog name任意。Description处选填,勾选Pubic,Readme随意<br><img src="https://i.imgur.com/yrprr0o.png" alt></p><h3 id="修改blog文件夹下的-congfig-yml文件"><a href="#修改blog文件夹下的-congfig-yml文件" class="headerlink" title="修改blog文件夹下的_congfig.yml文件"></a>修改blog文件夹下的_congfig.yml文件</h3><p>打开配置文件，搜索deploy，修改参数，注意参数后的冒号:和值中间要用空格隔开</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">deploy</span>:</span><br><span class="line">  <span class="attribute">type</span>: git  </span><br><span class="line">  <span class="attribute">repository</span>: <span class="attribute">https</span>:<span class="comment">//github.com/&lt;github账号名&gt;/&lt;blog name&gt;.github.io.git #就是仓库的网址后加上 .git  </span></span><br><span class="line">  <span class="attribute">branch</span>: master</span><br></pre></td></tr></table></figure><h3 id="cmd指令"><a href="#cmd指令" class="headerlink" title="cmd指令"></a>cmd指令</h3><p>保存后，在博客文件下进入cmd<br>（tips:在目录下<code>ctrl+shift</code>同时鼠标右键，即可在此处打开命令行，如果右键没有添加打开cmd的快捷指令，避免使用cd切换）</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">E:<span class="symbol">\m</span>yblogflie<span class="symbol">\b</span>log&gt;npm install hexo-deployer-git --save  </span><br><span class="line">E:<span class="symbol">\m</span>yblogfile<span class="symbol">\b</span>log&gt;hexo d -g</span><br></pre></td></tr></table></figure><p>tips：第一个npm指令可能速度很慢，可以先翻墙然后执行该指令<br>hexo d -g 部署到github，（-g生成静态文件），中途会跳出界面提示登录github账号<br>最后出现<code>INFO Deploy done: git</code>就代表部署成功，可以进入github自己的仓库查看  </p><h3 id="配置github-io"><a href="#配置github-io" class="headerlink" title="配置github.io"></a>配置github.io</h3><p>进入github中的博客仓库，点击settings页面拉到最下方GitHub Pages<br><img src="https://i.imgur.com/LuLSqWH.png" alt><br> 可以看到 Your site is published at <a href="https://blogname.github.io" target="_blank" rel="noopener">https://blogname.github.io</a> 如上图所示，由于我绑定了自己的域名，因此显示的是新的域名<a href="http://www.muyimuyi.xyz/">http://www.muyimuyi.xyz/</a> 下方的Custom domain就是选择绑定的域名，如果不绑定就不需要填写。</p><p><strong> <a href="https://blogname.github.io就是博客位置，可以点击访问查看博客信息" target="_blank" rel="noopener">https://blogname.github.io就是博客位置，可以点击访问查看博客信息</a></strong></p><h1 id="写文章和发布"><a href="#写文章和发布" class="headerlink" title="写文章和发布"></a>写文章和发布</h1><h2 id="使用hexo-new-文章名"><a href="#使用hexo-new-文章名" class="headerlink" title="使用hexo new 文章名"></a>使用<code>hexo new 文章名</code></h2><p>在blog文件夹下进入cmd，使用<code>hexo new blogname</code> 发布一篇名叫blogname的文章  </p><h2 id="使用-hexo-admin"><a href="#使用-hexo-admin" class="headerlink" title="使用 hexo admin"></a>使用 hexo admin</h2><p>hexo-admin是一款在线可视化发布文章的插件，可以选择文章的tag category 点击publish按钮即可，同时posts文件夹下面出现该md文件<br>安装方法如下，在blog文件夹进入cmd  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> <span class="comment">--save hexo-admin  #安装hexo-admin</span></span><br><span class="line">hexo <span class="keyword">server</span> -d</span><br><span class="line"><span class="keyword">open</span> <span class="keyword">http</span>://localhost:<span class="number">4000</span>/<span class="keyword">admin</span>/  <span class="comment">#或者在浏览器中打开该网址</span></span><br></pre></td></tr></table></figure><p>打开后界面如下<br><img src="https://i.imgur.com/QqwzpDZ.png" alt>  </p><h2 id="或者-直接在本地书写md文件，放在post目录下即可"><a href="#或者-直接在本地书写md文件，放在post目录下即可" class="headerlink" title="或者 直接在本地书写md文件，放在post目录下即可"></a>或者 直接在本地书写md文件，放在post目录下即可</h2><p><strong>写完文章后，部署。写完文章使用 <code>hexo s --debug</code>进行调试，查看效果，可以及时检查效果。确认无误后可以依次使用清除、生成静态文件、部署的指令</strong>  </p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">hexo clean</span>  </span><br><span class="line"><span class="attribute">hexo g</span>  </span><br><span class="line"><span class="attribute">hexo d</span></span><br></pre></td></tr></table></figure><h1 id="主题的修改-特色功能添加"><a href="#主题的修改-特色功能添加" class="headerlink" title="主题的修改 特色功能添加"></a>主题的修改 特色功能添加</h1><blockquote><p>我使用的是next主题，该主题地址 <a href="https://github.com/theme-next/hexo-theme-next" target="_blank" rel="noopener">Next</a><br>该主题的修改，功能添加，网上很多教程，自己搜索即可。。。。。。。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【长期更新】日常遇到的坑</title>
      <link href="/2019/06/09/%E4%B8%80%E4%BA%9B%E5%B0%8F%E9%97%AE%E9%A2%98/"/>
      <url>/2019/06/09/%E4%B8%80%E4%BA%9B%E5%B0%8F%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="偶尔遇到的小问题"><a href="#偶尔遇到的小问题" class="headerlink" title="偶尔遇到的小问题"></a>偶尔遇到的小问题</h1><a id="more"></a><h2 id="numpy-和-cv2-的几个尺寸变换"><a href="#numpy-和-cv2-的几个尺寸变换" class="headerlink" title="numpy  和 cv2 的几个尺寸变换"></a>numpy  和 cv2 的几个尺寸变换</h2><h3 id="resize-和-reshape"><a href="#resize-和-reshape" class="headerlink" title="resize  和 reshape"></a>resize  和 reshape</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line">img = cv2.imread(img_path) <span class="comment"># 实际上是一个np.array</span></span><br><span class="line"></span><br><span class="line">resized_img1 = cv2.resize(img,(<span class="number">500</span>,<span class="number">500</span>)) <span class="comment">#直接修改数组尺寸  这个函数有返回值 不会修改原来的img 因此需要赋给新的变量  但是，！！！只需要指明宽和高，3通道不用注明</span></span><br><span class="line">resized_img2 = np.resize(img,(<span class="number">500</span>,<span class="number">500</span>,<span class="number">3</span>))  <span class="comment"># 这个函数有返回值 不会修改原来的img 如果是三通道图片要 指明宽高和通道数 因为他是将整个数组resize</span></span><br><span class="line"></span><br><span class="line">resized_img3 = img.resize(<span class="number">500</span>,<span class="number">500</span>,<span class="number">3</span>) <span class="comment">#这个对象内置方法需要指明通道 但是 resized_img3 是空值 它没有返回值  所以直接 img.resize即可 </span></span><br><span class="line"></span><br><span class="line">resized_img4 = img.reshape((<span class="number">50</span>,<span class="number">50</span>,<span class="number">3</span>))  <span class="comment"># 这个操作不会改变原来的数组img  reshape是在原有数组操作，因此总共的元素个数不能变，比如原来 100*100*3 reshape后的 m*n*k*l也必须等于那么多</span></span><br><span class="line"></span><br><span class="line">resized_img5 = np.reshape(img,(<span class="number">50</span>,<span class="number">50</span>,<span class="number">3</span>)) <span class="comment">#和上面的一样</span></span><br></pre></td></tr></table></figure><p>==总之，改变图像大小cv2.resize(img,(width,height))即可==</p><h2 id="PIL-和-cv2"><a href="#PIL-和-cv2" class="headerlink" title="PIL 和 cv2"></a>PIL 和 cv2</h2><h3 id="读取图片"><a href="#读取图片" class="headerlink" title="==读取图片=="></a>==读取图片==</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line">img = Image.open(img_path) <span class="comment">#PIL读取的，返回的img是一个对象，如 JPEG对象</span></span><br><span class="line">img = cv2.imread(img_path,<span class="number">0</span>) <span class="comment">#cv2 读取的，返回的img是一个np.array数组 第二个参数表示读取模式，0表示灰度图，默认是3通道的RGB </span></span><br><span class="line"><span class="comment"># cv2 的一个沙雕(我觉得)机制，imread读取失败不会报错，而是 img 变成Nonetype的对象，后续使用才能发现读取失败</span></span><br></pre></td></tr></table></figure><h3 id="裁剪操作"><a href="#裁剪操作" class="headerlink" title="==裁剪操作=="></a>==裁剪操作==</h3><p><img src="http://ww1.sinaimg.cn/large/0071ouepgy1g2alvhdsz1j30cn09iwer.jpg" alt="image"></p><p>​                                                                                    图1 图像的像素坐标系X-Y</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 图像坐标系 都是以图像的左上角为原点，x向右，y向下的像素坐标系 </span></span><br><span class="line"><span class="comment"># PIL 的裁剪，剪出上图所示的红色矩形框内容 内置方法crop即可 ，传入裁剪区域左上角和右下角坐标</span></span><br><span class="line">crop_img = img.crop(xmin , ymin ,xmax ,ymax) </span><br><span class="line"></span><br><span class="line"><span class="comment"># cv2 的裁剪 ，通常使用 数组的切片操作</span></span><br><span class="line">crop_img = img[ ymin:ymax , xmin:xmax] <span class="comment"># 注意坐标的顺序即可，以及不需要通道[x1:x2,y1:y2,:]这种切片</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 给cv2.的指定位置(x,y)赋值，RGB像素赋值的方法是 img[x,y,:] = (r,g,b) 或者 img[x,y] = color ，color是一个数字</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> coding </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title></title>
      <link href="/archives/index.html"/>
      <url>/archives/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>about</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<p>  a SWJTUer  major in electronic information engineering , interested in cv and python. </p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Tag cloud</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
